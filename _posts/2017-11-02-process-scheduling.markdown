---
layout: post
title: "[OS] 프로세스 스케쥴링 종류"
date: 2017-11-02
categories:
  - OS
image: /assets/images/fw1.jpg
image-sm: /assets/images/fw2.jpg
---

{:.no_toc}

* Will be replaced with the ToC, excluding the "Contents" header
{:toc}  


# 프로세스 스케쥴링

## ⭐️ 우선순위 스케쥴링(priority scheduling)

### 1. 개요

- 우선순위가 높은 프로세스에 CPU를 우선 할당하는 스케줄링 방식
- 우선순위가 같으면 [FCFS 스케줄링](#fcfs--)
- 우선순위는 내부적/외부적 조건에 따라 정의될 수 있음
  - 시간 제한, 메모리 요구량, 열린 파일의 수, 프로세스의 중요성, 자원사용 비용 등
  - 예를 들어 [SJF 스케줄링](#sjf----)은 버스트 시간이 짧을수록 우선순위를 높게 책정하는 경우라 할 수 있음


- [선점형, 비선점형](#section-23) 모두 가능

### 2. 예시

| 프로세스 | 버스트 시간 | 우선순위[^1] | 턴어라운드 시간 | 대기 시간 |
| ---- | ------ | -------- | -------- | ----- |
| P1   | 10     | 3        | 16       | 6     |
| P2   | 1      | 1        | 1        | 0     |
| P3   | 2      | 4        | 18       | 16    |
| P4   | 1      | 5        | 19       | 18    |
| P5   | 5      | 2        | 6        | 1     |
| 평균   | -      | -        | 12       | 8.2   |

![E6D080E0-435F-47EC-8339-180E5F9BF1B2](https://ws4.sinaimg.cn/large/006tNbRwgy1fkfgy0mr4mj30nc03mwei.jpg) 

- **평균 대기 시간 = ( 6 + 0 + 16 + 18 + 1 ) / 5 = 8.2**

### 3. 문제점 및 개선

- 무기한 봉쇄[^2] 발생 가능
- 노화(aging)에 따라 우선순위를 높여주면 해결 가능

### 4.  참고

- [제타위키 - 우선순위 스케쥴링](https://zetawiki.com/wiki/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81){: target="_blank" }

## ⭐️ FCFS 스케쥴링 (선입선처리)

### 1. 개요

**First-Come, First-Served scheduling**

**FSCS scheduling, FIFO scheduling**

**FCFS 스케줄링, 선입선처리 스케줄링, 선입선출 스케줄링**

- 가장 단순한 스케줄링
- CPU 요청 순서대로 할당
- 먼저 사용신청을 한 프로세스부터 차례로 CPU를 할당함
- [**비선점** 스케줄링](#non-preemptive-scheduling) 중 한가지

### 2. 예시 1

- P1, P2, P3 순으로 요청

| **프로세스** | **버스트 시간** | **대기 시간** | **턴어라운드 시간** |
| -------- | ---------- | --------- | ------------ |
| **P1**   | **24**     | **0**     | **24**       |
| **P2**   | **3**      | **24**    | **27**       |
| **P3**   | **3**      | **27**    | **30**       |
| **평균**   | **-**      | **17**    | **27**       |

![A69DDE74-AB02-40D8-8AB9-216D58D1197A](https://ws2.sinaimg.cn/large/006tKfTcgy1fkh0guh266j30r203gq2x.jpg)

- **평균 대기 시간 = ( 0 + 24 + 27 ) / 3 = 17**

### 3. 예시 2

- P2, P3, P1 순으로 요청

| **프로세스** | **버스트 시간** | **대기 시간** | **턴어라운드 시간** |
| -------- | ---------- | --------- | ------------ |
| **P2**   | **3**      | **0**     | **3**        |
| **P3**   | **3**      | **3**     | **6**        |
| **P1**   | **24**     | **6**     | **30**       |
| **평균**   | **-**      | **17**    | **27**       |

![3C4C36BC-F672-4D9A-AE19-609CFD349678](https://ws1.sinaimg.cn/large/006tKfTcgy1fkh0ss36z8j30qy03mq2x.jpg)

- **평균 대기 시간 = ( 6 + 0 + 3 ) / 3 = 3**

### 4. 참고

- [제타위키 - FCFS 스케쥴링](https://zetawiki.com/wiki/FCFS_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81){: target="_blank" }

## ⭐️ SJF 스케쥴링 (최단 작업 우선)

### 1. 개요

**shortest-job-first scheduling; SJF scheduling**

**최단 작업 우선 스케줄링; SJF 스케줄링, SJF 알고리즘**

- 버스트 시간이 짧은 프로세스부터 CPU 할당
- 버스트 시간이 짧은 것을 우선 처리하는 스케줄링 방식
- 버스트 시간이 짧을수록 우선순위를 높게 책정하는 [우선순위 스케줄링](#header-c9)
- 버스트 시간이 같으면 [FCFS 스케줄링](#header-c98)
- **[비선점형](#header-c436), [선점형](#header-c456) 모두 가능**

### 2. 예시 1

| **프로세스** | **버스트 시간** | **턴어라운드 시간** | **대기 시간** |
| -------- | ---------- | ------------ | --------- |
| **P1**   | **6**      | **9**        | **3**     |
| **P2**   | **8**      | **24**       | **16**    |
| **P3**   | **7**      | **16**       | **9**     |
| **P4**   | **3**      | **3**        | **0**     |
| **평균**   | **-**      | **13**       | **7**     |

![749D984C-85A1-4819-A9E4-79353E9A34C9](https://ws3.sinaimg.cn/large/006tKfTcgy1fkh13a7g22j30lm03ojre.jpg)

- **평균 대기 시간 = ( 3 + 16 + 9 + 0 ) / 4 = 7**

### 3. 예시 2

| **프로세스** | **도착 시간** | **버스트 시간** | **턴어라운드 시간** | **대기 시간** |
| -------- | --------- | ---------- | ------------ | --------- |
| **P1**   | **0**     | **8**      | **8**        | **0**     |
| **P2**   | **1**     | **4**      | **11**       | **7**     |
| **P3**   | **2**     | **9**      | **24**       | **15**    |
| **P4**   | **3**     | **5**      | **14**       | **9**     |
| **평균**   | **-**     | **-**      | **14.25**    | **7.75**  |

![B35BE223-CB85-44DB-A0B6-4F9A3C98B5E8](https://ws1.sinaimg.cn/large/006tKfTcgy1fkh10rvdkkj30ng03gglm.jpg)

- **평균 대기 시간 = ( 0 + 7 + 15 + 9 ) / 4 = 7.75**

### 4. 문제점 및 개선

- 최적이긴 하지만 CPU 버스트 시간을 미리 알 수가 없음
- 따라서 다음 버스트 시간이 이전 버스트 시간과 비슷할 것이라고 예측하여 적용
- 다음 버스트 시간 = 이전 버스트 시간들의 [지수 평균](https://zetawiki.com/wiki/%EC%A7%80%EC%88%98_%ED%8F%89%EA%B7%A0){: target="_blank" }

### 5. 참고

- [제타위키 - SJF 스케쥴링](https://zetawiki.com/wiki/SJF_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81){: target="_blank" }

## ⭐️ RR 스케쥴링 (라운드 로빈)

### 1. 개요

**round-robin scheduling; RR scheduling**

**라운드로빈 스케줄링; RR 스케줄링; RR 알고리즘**

- [선점형 스케줄링](#preemptive-scheduling)의 하나
- [시분할 시스템](https://zetawiki.com/wiki/%EC%8B%9C%EB%B6%84%ED%95%A0_%EC%8B%9C%EC%8A%A4%ED%85%9C){: target="_blank" }을 위해 설계됨
- 시간 할당량(time quantum) 단위로 CPU를 할당
  - 일반적으로 `10` ~ `100ms`
- 알고리즘의 성능은 시간 할당량의 크기에 좌우됨
  - 시간할당량이 매우 크면 [FCFS 스케줄링](#header-c93)과 같아짐
  - 시간할당량이 매우 작으면 프로세서 공유와 같아짐[^3]

### 2. 예시 1

- 시간할당량 = 4ms

| 프로세스 | 버스트 시간 | 턴어라운드 시간 | 대기 시간 |
| ---- | ------ | -------- | ----- |
| P1   | 24     | 30       | 6     |
| P2   | 3      | 7        | 4     |
| P3   | 3      | 10       | 7     |
| 평균   | -      | 15.67    | 5.67  |

![83D64680-EFDD-451B-9B35-6DE64CF88994](https://ws4.sinaimg.cn/large/006tKfTcgy1fkh2cbaf5ej30qy03o0ss.jpg)

- **평균 대기 시간 = ( 6 + 4 + 7 ) / 3 = 5.67**

### 3. 예시 2

- 시간할당량 = 3ms

| 프로세스 | 도착 시간 | 버스트 시간 | 턴어라운드 시간 | 대기 시간 |
| ---- | ----- | ------ | -------- | ----- |
| P1   | 0     | 5      | 14       | 9     |
| P2   | 1     | 3      | 5        | 2     |
| P3   | 2     | 8      | 20       | 12    |
| P4   | 3     | 6      | 17       | 11    |
| 평균   | -     | -      | 14       | 8.5   |

![97291568-876B-4182-B7EE-35A36BB72D0B](https://ws1.sinaimg.cn/large/006tKfTcgy1fkh2d34x85j30ka03ot90.jpg)

- **평균 대기 시간 = ( 9 + 2 + 12 + 11 ) / 4 = 8.5**

### 6. 참고

- [제타위키 - RR 스케쥴링](https://zetawiki.com/wiki/RR_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81){: target="_blank" }

## ⭐️ SRT 스케쥴링 (최단 잔여시간)

### 1. 개요

**shortest remaining time first scheduling; SRTF scheduling, shortest remaining time; SRT**

**최단잔여시간 우선 스케줄링; SRTF 스케줄링; SRT 스케줄링**

- **[선점형](#preemptive-scheduling) [SJF 스케줄링](#sjf----)**
- **진행 중인 프로세스가 있어도 Sleep**시키고 `최단 잔여시간 프로세스`에 우선권 부여

### 2. 예시

- 프로세스 4개의 도착시각과 버스트시간이 주어질 경우...

| **프로세스** | **도착시각**  | **버스트 시간** | **종료시각**  | **턴어라운드 시간** | **대기 시간** |
| -------- | --------- | ---------- | --------- | ------------ | --------- |
| **P1**   | **00:00** | **8**      | **00:17** | **17**       | **9**     |
| **P2**   | **00:01** | **4**      | **00:05** | **4**        | **0**     |
| **P3**   | **00:02** | **9**      | **00:26** | **24**       | **15**    |
| **P4**   | **00:03** | **5**      | **00:10** | **7**        | **2**     |
| **평균**   | **-**     | **-**      | **-**     | **13**       | **6.5**   |

![F7425703-DC7C-4DF7-8067-9AC3245B14D9](https://ws2.sinaimg.cn/large/006tKfTcgy1fkh18zea4hj30nk03o0sy.jpg)

- **평균 대기 시간 = ( 9 + 0 + 15 + 2 ) / 4 = 6.5**

### 4. 참고

- [제타위키 - SRT 스케쥴링](https://zetawiki.com/wiki/SRT_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81){: target="_blank" }

## ❗️ 비선점 스케줄링, 선점 스케줄링

### 1. 스케줄링 시점

- 스케줄링은 다음과 같이 프로세스 상태가 전환될 때 발생함

> 1. **수행 → 대기 (예: I/O 요청, 자식프로세스 종료 대기 등)**
> 2. **수행 → 준비 (예: 인터럽트 발생)**
> 3. **대기 → 준비 (예: I/O 완료)**
> 4. **수행 → 종료**

- 1, 4번은 프로세스가 스스로 CPU를 놓아주는 시점

### 2. 비선점 스케줄링(non-preemptive scheduling)

- OS가 CPU 사용권을 선점하지 않음
- 프로세스에게 자율적으로 반납하도록 하는 방식
- OS가 정책에 따라 적당한 프로세스에게 CPU를 빌려주되 반납은 자율적으로 하도록 함
- 실행 중인 프로세스가 CPU를 스스로 반납하기 전까지 OS가 사용권을 가져올 수 없는 스케줄링 방식
- 스케줄링 시점 1, 4번(프로세스 스스로 반납시)에서만 스케줄링 가능
- 예: [FCFS 스케줄링](#fcfs--)

### 3. 선점 스케줄링(preemptive scheduling)

- OS가 CPU 사용권을 선점함
- OS가 적당한 프로세스에게 CPU를 빌려주고, 필요시에는 사용중이라도 회수함
- 필요시 OS가 실행 중인 프로세스로부터 CPU 사용권을 가져올 수 있는 스케줄링 방식
- 스케줄링 시점 1, 2, 3, 4번 모두에서 스케줄링 가능
- 예: [RR 스케줄링](#rr---), [SRT 스케쥴링](#srt---)

### 4. 참고

- [http://en.wikipedia.org/wiki/Preemption_(computing)](http://en.wikipedia.org/wiki/Preemption_(computing))
- [http://en.wikipedia.org/wiki/Scheduling_(computing)](http://en.wikipedia.org/wiki/Scheduling_(computing))
- [http://en.wikipedia.org/wiki/Nonpreemptive_multitasking](http://en.wikipedia.org/wiki/Nonpreemptive_multitasking)

## 주석

[^1]: 여기서는 숫자가 작을수록 우선순위가 높음. 반대로 표현하는 경우도 있음
[^2]: 자원이 부족한 상태에서 우선순위가 높은 프로세스가 계속 들어와서 우선순위가 낮은 프로세스가 계속 수행되지 못하는 현상
[^3]: n개의 프로세스가 있다면 1/n 속도로 수행됨 (단, 문맥교환 시간은 무시된다고 가정할 때)



